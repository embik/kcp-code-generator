package listergen

import (
	"io"
	"text/template"

	"github.com/kcp-dev/code-generator/pkg/parser"
	"k8s.io/code-generator/cmd/client-gen/types"
)

type Lister struct {
	APIPath         string
	Group           parser.Group
	Version         types.PackageVersion
	Kind            parser.Kind
	UpstreamAPIPath string
}

func (l *Lister) WriteContent(w io.Writer) error {
	templ, err := template.New("lister").Funcs(templateFuncs).Parse(lister)
	if err != nil {
		return err
	}

	m := map[string]interface{}{
		"apiPath":               l.APIPath,
		"group":                 l.Group,
		"version":               l.Version,
		"kind":                  &l.Kind,
		"upstreamAPIPath":       l.UpstreamAPIPath,
		"useUpstreamInterfaces": l.UpstreamAPIPath != "",
	}
	return templ.Execute(w, m)
}

var lister = `
//go:build !ignore_autogenerated
// +build !ignore_autogenerated

// Code generated by kcp code-generator. DO NOT EDIT.

package {{.version.String}}

import (
	
	{{.group.Name}}{{.version.String}} "{{.apiPath}}"
	"github.com/kcp-dev/logicalcluster/v2"
	"k8s.io/client-go/tools/cache"
	"k8s.io/apimachinery/pkg/labels"
	"k8s.io/apimachinery/pkg/api/errors"
	apimachinerycache "github.com/kcp-dev/apimachinery/pkg/cache"
	{{if .useUpstreamInterfaces -}}
	{{.group.Name}}{{.version.String}}listers "{{.upstreamAPIPath}}/{{.group.Name}}/{{.version.String}}"
	{{end -}}
)

{{if .useUpstreamInterfaces -}}
var _ {{.group.Name}}{{.version.String}}listers.{{.kind.String}}Lister = &{{.kind.String}}ClusterLister{}
{{end -}}

{{if not .useUpstreamInterfaces -}}
// {{.kind.String}}ClusterLister can list everything or scope by workspace
{{else -}}
// {{.kind.String}}ClusterLister implements the {{.group.Name}}{{.version.String}}listers.{{.kind.String}}Lister interface.
{{end -}}
type {{.kind.String}}ClusterLister struct {
	indexer cache.Indexer
}

// New{{.kind.String}}ClusterLister returns a new {{.kind.String}}ClusterLister.
{{if not .useUpstreamInterfaces -}}
func New{{.kind.String}}ClusterLister(indexer cache.Indexer) *{{.kind.String}}ClusterLister {
{{else -}}
func New{{.kind.String}}ClusterLister(indexer cache.Indexer) {{.group.Name}}{{.version.String}}listers.{{.kind.String}}Lister {
{{end -}}
	return &{{.kind.String}}ClusterLister{indexer: indexer}
}

// List lists all {{.group.Name}}{{.version.String}}.{{.kind.String}} in the indexer.
func (s {{.kind.String}}ClusterLister) List(selector labels.Selector) (ret []*{{.group.Name}}{{.version.String}}.{{.kind.String}}, err error) {
	err = cache.ListAll(s.indexer, selector, func(m interface{}) {
		ret = append(ret, m.(*{{.group.Name}}{{.version.String}}.{{.kind.String}}))
	})
	return ret, err
}
{{ if and .useUpstreamInterfaces (not .kind.IsNamespaced) -}}
// Get retrieves the {{.group.Name}}{{.version.String}}.{{.kind.String}} from the indexer for a given name.
func (s {{.kind.String}}ClusterLister) Get(name string) (*{{.group.Name}}{{.version.String}}.{{.kind.String}}, error) {
	panic("Calling 'Get' is not supported before scoping lister to a workspace")
}
{{end -}}
{{ if and .useUpstreamInterfaces .kind.IsNamespaced -}}
// {{.kind.Plural}} returns an object that can list and get {{.group.Name}}{{.version.String}}.{{.kind.String}}.
func (s {{.kind.String}}ClusterLister) {{.kind.Plural}}(namespace string) {{.group.Name}}{{.version.String}}listers.{{.kind.String}}NamespaceLister {
	panic("Calling '{{.kind.Plural}}' is not supported before scoping lister to a workspace")
}
{{end -}}

// Cluster returns an object that can list and get {{.group.Name}}{{.version.String}}.{{.kind.String}}.

{{if not .useUpstreamInterfaces -}}
func (s {{.kind.String}}ClusterLister) Cluster(cluster logicalcluster.Name) *{{.kind.String}}Lister {
{{else -}}
func (s {{.kind.String}}ClusterLister) Cluster(cluster logicalcluster.Name){{.group.Name}}{{.version.String}}listers.{{.kind.String}}Lister {
{{end -}}
	return &{{.kind.String}}Lister{indexer: s.indexer, cluster: cluster}
}

{{if not .useUpstreamInterfaces -}}
// {{.kind.String}}Lister can list everything inside a cluster or scope by namespace
{{else -}}
// {{.kind.String}}Lister implements the {{.group.Name}}{{.version.String}}listers.{{.kind.String}}Lister interface.
{{end -}}
type {{.kind.String}}Lister struct {
	indexer cache.Indexer
	cluster logicalcluster.Name
}

// List lists all {{.group.Name}}{{.version.String}}.{{.kind.String}} in the indexer.
func (s {{.kind.String}}Lister) List(selector labels.Selector) (ret []*{{.group.Name}}{{.version.String}}.{{.kind.String}}, err error) {
	selectAll := selector == nil || selector.Empty()

	key := apimachinerycache.ToClusterAwareKey(s.cluster.String(), "", "")
	list, err := s.indexer.ByIndex(apimachinerycache.ClusterIndexName, key)
	if err != nil {
		return nil, err
	}

	for i := range list {
		obj := list[i].(*{{.group.Name}}{{.version.String}}.{{.kind.String}})
		if selectAll {
			ret = append(ret, obj)
		} else {
			if selector.Matches(labels.Set(obj.GetLabels())) {
				ret = append(ret, obj)
			}
		}
	}

	return ret, err
}

{{ if  not .kind.IsNamespaced -}}
// Get retrieves the {{.group.Name}}{{.version.String}}.{{.kind.String}} from the indexer for a given name.
func (s {{.kind.String}}Lister) Get(name string) (*{{.group.Name}}{{.version.String}}.{{.kind.String}}, error) {
	key := apimachinerycache.ToClusterAwareKey(s.cluster.String(), "", name)
	obj, exists, err := s.indexer.GetByKey(key)
	if err != nil {
		return nil, err
	}
	if !exists {
		return nil, errors.NewNotFound({{.group.Name}}{{.version.String}}.Resource("{{.kind.String}}"), name)
	}
	return obj.(*{{.group.Name}}{{.version.String}}.{{.kind.String}}), nil
}
{{ else -}}
// {{.kind.Plural}} returns an object that can list and get {{.group.Name}}{{.version.String}}.{{.kind.String}}.
{{if not .useUpstreamInterfaces -}}
func (s {{.kind.String}}Lister) {{.kind.Plural}}(namespace string) *{{.kind.String}}NamespaceLister {
{{else -}}
func (s {{.kind.String}}Lister) {{.kind.Plural}}(namespace string) {{.group.Name}}{{.version.String}}listers.{{.kind.String}}NamespaceLister {
{{end -}}
	return &{{.kind.String}}NamespaceLister{indexer: s.indexer, cluster: s.cluster, namespace: namespace}
}

{{ if not .useUpstreamInterfaces -}}
// {{.kind.String}}NamespaceLister helps list and get {{.group.Name}}{{.version.String}}.{{.kind.String}}.
// All objects returned here must be treated as read-only.
{{ end -}}
{{ if .useUpstreamInterfaces -}}
// {{.kind.String}}NamespaceLister implements the {{.group.Name}}{{.version.String}}listers.{{.kind.String}}NamespaceLister interface.
{{ end -}}
type {{.kind.String}}NamespaceLister struct {
	indexer   cache.Indexer
	cluster   logicalcluster.Name
	namespace string
}

// List lists all {{.group.Name}}{{.version.String}}.{{.kind.String}} in the indexer for a given namespace.
func (s {{.kind.String}}NamespaceLister) List(selector labels.Selector) (ret []*{{.group.Name}}{{.version.String}}.{{.kind.String}}, err error) {
	selectAll := selector == nil || selector.Empty()

	key := apimachinerycache.ToClusterAwareKey(s.cluster.String(), s.namespace, "")
	list, err := s.indexer.ByIndex(apimachinerycache.ClusterAndNamespaceIndexName, key)
	if err != nil {
		return nil, err
	}

	for i := range list {
		obj := list[i].(*{{.group.Name}}{{.version.String}}.{{.kind.String}})
		if selectAll {
			ret = append(ret, obj)
		} else {
			if selector.Matches(labels.Set(obj.GetLabels())) {
				ret = append(ret, obj)
			}
		}
	}
	return ret, err
}

// Get retrieves the {{.group.Name}}{{.version.String}}.{{.kind.String}} from the indexer for a given namespace and name.
func (s {{.kind.String}}NamespaceLister) Get(name string) (*{{.group.Name}}{{.version.String}}.{{.kind.String}}, error) {
	key := apimachinerycache.ToClusterAwareKey(s.cluster.String(), s.namespace, name)
	obj, exists, err := s.indexer.GetByKey(key)
	if err != nil {
		return nil, err
	}
	if !exists {
		return nil, errors.NewNotFound({{.group.Name}}{{.version.String}}.Resource("{{.kind.String}}"), name)
	}
	return obj.(*{{.group.Name}}{{.version.String}}.{{.kind.String}}), nil
}
{{ end -}}
`
