package clientgen

import (
	"io"
	"strings"
	"text/template"

	"github.com/kcp-dev/code-generator/pkg/util"
)

type Fake struct {
	// SingleClusterFakeClientPackagePath is the root directory under which single-cluster-aware fake clients exist.
	// e.g. "k8s.io/client-go/kubernetes/fake"
	SingleClusterFakeClientPackagePath string
}

func (c *Fake) WriteContent(w io.Writer) error {
	templ, err := template.New("clientset").Funcs(template.FuncMap{
		"upperFirst": util.UpperFirst,
		"lowerFirst": util.LowerFirst,
		"toLower":    strings.ToLower,
	}).Parse(fake)
	if err != nil {
		return err
	}

	m := map[string]interface{}{
		"singleClusterClientFakePackagePath": c.SingleClusterFakeClientPackagePath,
	}
	return templ.Execute(w, m)
}

var fake = `
//go:build !ignore_autogenerated
// +build !ignore_autogenerated

// Code generated by kcp code-generator. DO NOT EDIT.

package fake

import (
	"fmt"

	kcpfake "github.com/kcp-dev/client-go/tools/fake"
	"github.com/kcp-dev/logicalcluster/v2"

	"k8s.io/apimachinery/pkg/runtime"

	client "{{.singleClusterClientFakePackagePath}}"
)

type ClusterInterface interface {
	Cluster(logicalcluster.Name) *client.Clientset
}

// ClusterClientset contains the clients for groups.
type ClusterClientset struct {
	fakeCache kcpfake.Cache[*client.Clientset]
}

// Cluster scopes this clientset to one cluster.
func (c *ClusterClientset) Cluster(name logicalcluster.Name) *client.Clientset {
	if name == logicalcluster.Wildcard {
		panic("A specific cluster must be provided when scoping, not the wildcard.")
	}
	return c.fakeCache.Cluster(name)
}

// NewSimpleClientset returns a clientset that will respond with the provided objects.
// It's backed by a very simple object tracker that processes creates, updates and deletions as-is,
// without applying any validations and/or defaults. It shouldn't be considered a replacement
// for a real clientset and is mostly useful in simple unit tests.
func NewSimpleClientset(objects ...runtime.Object) *ClusterClientset {
	objectsByCluster := map[logicalcluster.Name][]runtime.Object{}
	for i := range objects {
		obj, ok := objects[i].(logicalcluster.Object)
		if !ok {
			panic(fmt.Sprintf("object[%d] is of type %T and cannot be inspected for a logical cluster!", i, objects[i]))
		}
		clusterName := logicalcluster.From(obj)
		if clusterName.Empty() {
			panic(fmt.Sprintf("object[%d] has no logical cluster set - ensure the logicalcluster.AnnotationKey is set in annotations", i))
		}
		objectsByCluster[clusterName] = append(objectsByCluster[clusterName], objects[i])
	}

	fakeCache := kcpfake.NewCache[*client.Clientset](
		kcpfake.Constructor[*client.Clientset]{
			NewSimpleClientset: client.NewSimpleClientset,
		},
	)

	for clusterName, objs := range objectsByCluster {
		fakeCache.Cluster(clusterName, objs...)	
	}

	return &ClusterClientset{fakeCache: fakeCache}
}
`
